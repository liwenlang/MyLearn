
	文件管理  
cat
　用来把文档串联后传到基本输出                        【Linux | 阵列】
more
用来一页一页翻动阅读                                【Linux | 阵列】
less
用来一页一页翻动阅读，但用法比more更灵活          【Linux | 阵列】
tail
用来强制获取文件新增的内容                          【Linux | 阵列】
tee
　用来从标准输入中读取数据，并输出到标准输出设备      【Linux | 阵列】
chattr
　用来设置ext2/ext3文件隐藏属性                      【Linux | 阵列】
lsattr
用来显示文件隐藏属性                                【Linux | 阵列】
find
用来在指定目录下查找文件                            【Linux | 阵列】
locate
用来查找符合条件的文档，根据数据库模糊匹配          【Linux | 阵列】
which
用来查找可执行文件位置                              【Linux | 阵列】
whereis
用来查找符合条件的源代码、二进制文件、帮助文件      【Linux | 阵列】
cksum
用来检查文件的CRC是否正确                          【Linux | 阵列】
dos2unix
用来将DOS格式的文本文件转换为UNIX格式            【Linux | 阵列】
file
　用来辨识文件类型                                    【Linux | 阵列】
umask
　用来设定权限掩码，默认权限-权限掩码 = 预设权限       【Linux | 阵列】
touch
　用来修改文件时间属性或创建空文件                    【Linux | 阵列】
mkdir
  用来创建空目录                                      【Linux | 阵列】
rm
　用来删除一个文件或目录                              【Linux | 阵列】
mv
　用来做文件名或目录更名，或将其移动位置              【Linux | 阵列】

cp
　用来Linux服务器内复制文件或目录                    【Linux | 阵列】
scp
　用来Linux服务器之间复制文件或目录                  【Linux | 阵列】
paste
　用来按列合并文件                                    【Linux | 阵列】
cut
　用来以行为单位截取指定长度的列                      【Linux | 阵列】
join
　用于将两个相关联的文件中，指定的栏位连接起来        【Linux | 阵列】
fold
　用来限制文件列宽                                    【Linux | 阵列】
colrm
　用来从文件中过滤掉指定的列                          【Linux | 阵列】
comm
　用来比较两个已经排过序的文件                        【Linux | 阵列】
patch
　用来修补文件或升级内核                              【Linux | 阵列】
split
　用来拆分大文件为多个小文件                          【Linux | 阵列】
csplit
　用来按照指定的范式来分割文件                        【Linux | 阵列】
cmp
　用来比较两个二进制文件是否有差异                    【Linux | 阵列】
diff
　用来比较文件的差异，逐行比较文本文件的异同处        【Linux | 阵列】
awk
　用来做样式扫描与处理的工具                          【Linux | 阵列】
ln
　用来为某个文件或目录在另外一个位置建一个同步的链接  【Linux | 阵列】
chown
　用来将指定的文件改为指定的用户或组                  【Linux | 阵列】
chmod
  用来改变Linux系统文件或目录的访问权限              【Linux | 阵列】
chgrp
　用来变更文件或目录的所属群组                        【Linux | 阵列】



	文档编辑
grep
　用来搜索过滤，功能强大                               【Linux | 阵列】
tr
　用来替换、删除文件中的字符                          【Linux | 阵列】
wc
　统计指定文件中的行数，单词数，字符数                【Linux | 阵列】
expr
　用来做手工命令计算器                                【Linux | 阵列】
sort
　用来将文本文件内容进行排序，以行来排序              【Linux | 阵列】
uniq
　用来检查及删除文件中重复出现的行列                  【Linux | 阵列】
nl
  用来显示文件中行号                                         【Linux | 阵列】
sed
　用来对文本文件中的行进行修改和编辑，删除，替换操作  【Linux | 阵列】
vi
　用来编辑文件，Linux下最常用的文本编辑器             【Linux | 阵列】

	磁盘管理       
cd
　用来切换工作目录                                    【Linux | 阵列】
df
　用来显示目前Linux系统上的文件系统的磁盘使用情况    【Linux | 阵列】
du
　用于显示指定目录或文件所占用的磁盘空间              【Linux | 阵列】
tree
　用来以树状图的方式列出目录的内容                    【Linux | 阵列】
ls
　用来列出工作目录下的子文件及子目录                  【Linux | 阵列】
pwd
用来显示工作目录名                                  【Linux | 阵列】
mount
　用来将其他文件系统挂载在Linux系统下                【Linux | 阵列】


	磁盘维护
badblocks
用来检查磁盘中损坏的区块                            【Linux|     】
dd
　用来对磁盘性能进行测试，数据拷贝                    【Linux | 阵列】
hdparm
　用来检测、显示及设定IDE或SCSI硬盘的参数            【Linux | 阵列】
sync
　用来将内存中的数据刷盘                              【Linux | 阵列】
mkfs
　用来在特定分区建立Linux文件系统                    【Linux | 阵列】
fsck
　用来检查并修复Linux文件系统                        【Linux | 阵列】
fdisk
　用来管理Linux磁盘分区                                    【Linux | 阵列】

	网络通讯
ping
　用来检查网络的连通性                                【Linux | 阵列】
wall
　用来将公告信息发送给终端机用户                      【Linux | 阵列】
mesg
　用来设置终端机的写入权限                            【Linux | 阵列】
talk
  用来与其他登录的用户双向通讯                        【Linux |     】
netstat
　用来获悉整个系统的网络情况                          【Linux | 阵列】
ifconfig
　用来查看和配置网络设备                                    【Linux | 阵列】





	系统管理
useradd
　用来创建用户帐号                                    【Linux | 阵列】
userdel
　用来删除用户帐号                                    【Linux | 阵列】
usermod
　用来修改用户帐号                                    【Linux | 阵列】
date
　用来显示或设定系统的日期与时间,可格式化输出          【Linux | 阵列】
exit
　用来离开当前的Shell                                 【Linux | 阵列】
ps
　用来静态查看系统进程的运行情况                      【Linux | 阵列】
fuser
　用来显示正在使用某个文件，socket的进程             【Linux | 阵列】
top
　用来查看系统CPU，内存，进程的使用情况             【Linux | 阵列】
kill
　用来杀掉或重启某个进程                              【Linux | 阵列】
pstree
　用来以树形结构形象显示进程之间关联                  【Linux | 阵列】
who
　用来查看登录者的信息                                【Linux | 阵列】
w
　用来查看登录者的信息及所做的操作                    【Linux | 阵列】
last
　用来列出截止目前登录过系统的用户信息                【Linux | 阵列】
sleep
　用来将目前动作延迟一段时间                          【Linux | 阵列】
shutdown
　用来关机，重启或发送告警信息                        【Linux | 阵列】
uptime
　用来查看当前时间；系统平均负载                      【Linux | 阵列】
iostat
　用来查看硬盘IO情况                                  【Linux | 阵列】



uname
　用来显示系统一些信息                                【Linux | 阵列】
sudo
　用来暂借root权限执行某些操作                             【Linux | 阵列】
stat
　用来显示文件的详细信息，包括atime, mtime, ctime    【Linux | 阵列】
lsmod
　用来列出已加载系统的模块                            【Linux | 阵列】
insmod
　用来载入模块。此类载入的模块，通常为设备驱动程序    【Linux | 阵列】
rmsmod
  用来卸载模块                                        【Linux | 阵列】
modinfo
　用来显示kernel模块的信息                           【Linux | 阵列】
modprobe
　用来显示，加载及删除相依的模块                       【Linux | 阵列】
free
　用来查看内存使用情况                                【Linux | 阵列】
tcpdump
  用来将网络中传送的数据包的"头"完全截获下来提供分析  【Linux |     】
ethtool
  用于查询及设置网卡参数                              【Linux | 阵列】
jobs
  用来查看后台执行的任务                              【Linux | 阵列】
id
　用来显示用户的UID，以及所属群组的GID              【Linux | 阵列】
history
　用来记录执行过的历史命令                            【Linux | 阵列】







	系统设置
passwd
　用来修改用户密码                                    【Linux | 阵列】
clear
　用来清除终端屏幕                                           【Linux | 阵列】
yum
　用来管理shell前端软件包                             【Linux |     】
ulimit
　用来控制shell程序的资源，同时对系统性能进行调优       【Linux | 阵列】
chkconfig
　用来检查和设置系统的各种服务                        【Linux | 阵列】
set
　用来依照不同的需求来设置所使shell的执行方式         【Linux | 阵列】
time
　用来量测特定指令所需消耗的时间及系统资源等资讯      【Linux | 阵列】
alias
　用来设置指令的别名                                         【Linux | 阵列】
declare
　用来声明shell变量                                   【Linux | 阵列】
export
　用来设置或显示环境变量                                    【Linux | 阵列】
dmesg
　用来显示开机信息                                    【Linux | 阵列】
enable
　用来开启或关闭shell内建指令                         【Linux | 阵列】
at
  用于设置定时任务，指定一个时间执行一个任务          【Linux | 阵列】
hwclock
  用来查询和设置硬件时钟                              【Linux | 阵列】
eval
　用来重新运算求出参数的内容                               【Linux | 阵列】
echo
  用来打印一段文字，起提示作用                        【Linux | 阵列】

	压缩解压
tar
　用来压缩、解压缩文件                                【Linux | 阵列】

	速查备忘
if条件语句
　if 语句的语法结构、实例说明                            
case选择语句
  case 语句的语法结构、实例说明  
for循环语句
  for语句的语法结构、实例说明
while循环语句
  while语句的语法结构、实例说明
输入输出重定向
文件描述符说明列表、全部命令行列表、Here Document
几种常用操作符
  字符串比较操作符、数字逻辑操作符、文件状态逻辑操作符
常用按键速查表
  TAB、CTRL+R、CTRL+U、CTRL+K、CTRL+D等常用按键
Linux启动顺序图
  从机器启动-->读取BIOS-->...再到登陆整个启动流程
Linux中的设备号
  Linux中各种常用设备号，比如说/dev/sda…
Shell中参数传递
  $#,$?, $*,$$, $!, $n等各种Shell中的参数
Linux的目录结构
  Linux第一层目录结构及其常用功能
VI/VIM键盘图
  完整，详备的vi/vim键盘图

1	文件管理
【cat命令】
 
【实例 | 技巧】
cat -n file1 > file2                   # 将file1加编号后输出到file2
cat -b file1 file2 >> file              # 给两文件加编号后后追加输出到file
cat /dev/null > /tmp/test.log         # 清空test.log文件
cat > newfile                        # 创建新文件， 输入内容并用Ctrl+D退出
cat /OSM/log/cur_debug/messages | more    # 用分页的方式来显示文件内容, 按Q键退出
 
【归纳 | 总结】
【总结一】:cat的四个主要功能
(1) 用来显示文件内容，内容多的话，与more, less配合使用 cat messages | more
(2) 用来创建一个新文件cat > newfile
(3) 用来合并多个文件cat -b file1 file2 > file
(4) 用来清空文件cat /dev/null > /tmp/test.txt
【总结二】:cat与tac命令区别
tac命令是cat的反写，功能也相反，是将文件从最末一行到第一行开始显示
	tac /etc/passwd
	cat /etc/passwd
【more命令】
 
【实例 | 技巧】
more file               # 分页的方式显示file文件
more -s file            # 碰到有两行以上的空格，以一行来显示
more +20 file          #  从第20行开始显示内容
cat file | more         # 与其他命令组合使用
【归纳 | 总结】
【备注一】more命令常用操作 :
	空格键(space)  表示向下翻一页
	Enter键        表示向下翻一行
	/str           表示向下搜索字符串"str"   
	:f             立刻显示文件名以及当前显示的行数
	q             离开  
【less命令】
 
【实例 | 技巧】
less /etc/man.config         # 常用用法
less file1 file2                #  同时显示两个文件
ps -ef | less                  # ps查看进程信息并以less分页显示
history | less                 # 用分页方式来显示history的内容
【归纳 | 总结】
【备注一】less命令常用操作 :
空格键        向下翻动一页
[pagedown]  向下翻动一页
[pageup]     向上翻动一页
/str          向下搜索"str" 
?str          向上搜索"str"   
n            重复前一个搜索(与/或?有关) 
N            反向重复前一个搜索(与/或者?有关) 
q            离开less命令
【tail命令】
 
【实例 | 技巧】
tail -f /OSM/log/cur_debug/messages       # 监控messages文件尾部内容，默认10行
tail -n 20 /OSM/log/cur_debug/messages   # 显示文件messeages最后20行
tail -n +10 2015.log                        # 从第10行开始显示2015.log文件的内容
【归纳 | 总结】
【备注一】tail命令的几点说明 :
(1) 该命令主要用来查看一个正在生产的文件是否有我们要找的关键字
(2) 主要参数就是-f, 也可连起来写: tailf /OSM/log/cur_debug/messages
【tee命令】
 
【实例 | 技巧】
echo "Hello,World" | tee out.txt       # tee out.txt  覆盖文件
echo 12345 | tee -                   # 比对结果，tee -输出到标准输出两次
history | tee history1 history2        # 输出history的执行结果，同时保留两份输出文件
ls -lart | tee -a file.txt | cat -n         # tee -a file.txt 追加的方式保存文件
ls -l * 2&>1 | tee -a out.txt           # 标准输出，标准错误均被tee读取
ls -lR /etc/ | tee A1.out | sort | tee A2.out | sort -r | tee A3.out | uniq -c | tee A4.out > A5.out
【归纳 | 总结】
【备注一】为什么在shell中要用tee命令
某些命令运行的结果会很长，你可能会用less 来上下看。再或者你可能会用>来重定向到文件里。但某些时候程序有可能需要你输入 y 来确认，或者某些程序运行的时间很长，仅仅重定向的话又不太确定是不是它在正常运行。tee 就能做到又输出到屏幕上，又同时重定向到文件。在Shell脚本中很常用
 
【chattr命令】
 
【实例 | 技巧】
chattr +i /etc/passwd         # 防止某个关键文件被修改
chattr -i /etc/passwd          # 关闭该文件的i属性
chattr +a /var/log/messages   # 只能添加数据，不能删除，常用于日志文件
【归纳 | 总结】
【备注一】关于chattr命令的几点说明:
(1) 该命令在系统数据安全方面非常重要，chattr命令最常用的属性就是a和i
(2) chmod只改变文件的读写、执行权限，更底层的属性是由chattr来改变的
(3) 如果用root账号还不能修改文件，就要考虑是否被锁定了，也就是chattr命令
(4) chattr命令并不适合所有的目录。该不能保护/、/dev、/tmp、/var目录
【lsattr命令】
 
【实例 | 技巧】
lsattr -aR /etc                         # 列出该文件的属性
lsattr /etc/passwd /etc/shadow        # 拿两个文件的属性显示出来
【归纳 | 总结】
【备注一】关于lsattr命令的几点说明:
(1) 如果用root账号还不能修改文件，就要考虑是否被锁定了，就要用lsattr命令
(2) 如果看到Operation not permitted报错， 就要考虑chattr,lsattr两个命令了
【find命令】
 
【实例 | 技巧】
find . -name "*.sh"  # 在当前目录及其子目录下，拿所有的sh文件找出来
find . -ctime -30     # 将当前目录及其子目录下，最近半小时内创建的文件列出
find $HOME -type f -size 0 -exec ls -l {} \;   #  查找主目录中所有空文件找出来，并列出
find . -type f -perm 644 -exec ls -l {} \;       # 查找权限符合的并列出
find /tmp -iname "*.log" | xargs -n50 grep "ERROR"  # xargs执行结果，iname忽略大小写
find . -name "[A-Z]*" -print file     # 当前目录下查找大写字母开头文件，并将其输出到file文件
find . -newer 2013.log ! -newer 2015.log  # 查找比第一个文件新，但比第二个文件旧的文件
find /etc /root ! -user root -mtime -2 -print # 查找这两个文件夹，非root创建,2天内有访问的文件
find ~ -maxdepth 2 -empty -not -name ".*" # 查找家目录及下一级目录下非隐藏空文件
find / -type f -exec ls -s {} \; | sort -n -r | head -5  # 查找系统中最大5个文件
find . -not -empty -type f -exec ls -s {} \; | sort -n  | head -5  # 当前目录下找非空最小的5个文件
find / -type f -name *.tmp -size +100M -exec rm -i {} \;"  # 查找100M以上tmp文件并删除
find . -perm 777 -print | xargs chmod –x  # 查找当前目录下权限为777，并去掉可执行权限
find . \( -name a.out -o -name '*.o' -o -name 'core' \) -exec rm {} \; # 清除c语言产生的临时文件
find . -type f -mtime +30 -name "*.log" -exec cp {} old \;  # 将30天前的空文件移到old目录下
find /tmp -name "^[0-9]{4}[AB].sh"  # 正则表达式运用, 2015A.sh或2014B.sh
find /tmp -name "*.sh" -exec cp {} {}.bak \; # 注意{}的运用
find . -name ".svn" -exec rm -rf {} \;   #  很常用的一个应用
find . -regex ‘.*/[0-9]\w.*’         # 匹配以数字开头的文件
【归纳 | 总结】
【备注一】关于find命令的几点说明:
	-exec command {} \;   # {}与\之间有空格，以;结束, 将查询到的结果执行command操作
	-exec 与 -ok 效果一样，只是多个提示，一种更安全，更友好的方式
	UNIX/Linux文件系统每个文件都有三种时间戳： 
访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间。 
修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间。 
变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。
(4)  类型参数列表： f 普通文件 l 符号连接 d 目录 c 字符设备 b 块设备 s 套接字 p Fifo
【备注二】find命令结合正则表示式使用示例:
 
【locate命令】
 
【实例 | 技巧】
locate passwd                # 查找passwd文件
locate -u                     # 手工升级数据库，一般是系统自动维护，更新的频率为每天
【归纳 | 总结】
【备注一】关于locate的几点说明:
(1) locate会去保存文档和目录名称的数据库内，查找合乎条件的文档或目录
(2) locate命令预设的数据库位于/var/lib/slocate目录里，文档名为slocate.db
(3) locate内容一般每日更新一次，也可locate -u 或updatedb来手工更新
【总结一】locate与find区别:
locate与find是查找文件中应用最频繁的。两者不同: find 是去硬盘找，locate 只在/var/lib/slocate资料库中找。locate的速度比find快，它并不是真的查找，而是查数据库，一般文件数据库在/var/lib/slocate/slocate.db中，所以locate的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护，也可以手工升级数据库
【总结二】find, which,whereis,locate区别:
(1) find 是直接在硬盘上搜寻，功能强大，但耗硬盘，一般不要用。常用于Shell脚本.
(2) which只能查可执行文件和别名, 并在PATH变量中查找
(3) whereis只能查二进制文件、说明文档，源文件等
(4) locate和whereis都是查数据库/var/lob/slocate/slocate.db里的内容。比find快
【which命令】
 
【实例 | 技巧】
which pwd                # 找出pwd的绝对路径
which grep cut ls          # 查看多条命令， 一同显示
【归纳 | 总结】
【备注一】关于which命令的几点说明:
	which命令的基本功能是查找可执行文件，主要是搜索命令所在目录
	whereis命令不仅能搜索命令所在目录，还能搜索其帮助文档存储路径
	whatis命令可以显示命令的简短信息，能够做什么用
	/sbin和/usr/sbin主要放root用户命令
	/bin和/usr/bin主要放置普通用户命令
【whereis命令】
 
【实例 | 技巧】
whereis -b bash    # 只查找二进制文件路径
whereis -m bash   # 只查找说明文件
【归纳 | 总结】
【备注一】关于whereis命令的几点说明:
(1)	whereis也是搜索/var/lib/slocate/slocate.db数据库，相比find而言，速度快
(2)	whereis与locate的区别在于:前者精确匹配，后者模糊查找，列出一串结果
【总结一】whereis执行结果说明:
(1) whereis的执行结果: whereis bash
bash:/bin/bash  /etc/bash.bashrc  /usr/share/man/man1/bash.1.gz
以上输出信息从左至右分别为查询的程序名、bash路径、bash的man手册页路径
(2) 可以手工执行/usr/bin/updatedb命令来更新数据库
【cksum命令】
 
【实例 | 技巧】
cksum A.tgz                # 计算A.tgz包的CRC
cksum /bin/* > /bin.cksum  # 一旦/bin该目录下有任何文件改动，bin.cksum就会改动
【归纳 | 总结】
【备注一】关于cksum命令的几点说明:
(1) CRC校验的标准由CCITT所指定，至少可检测出99.998%的已知错误
(2) 经cksum进行校验后，该指令会返回校验结果供用户核对文件是否正确无误
(3) 若指定的文件名为"-"， 则指令chsum会从标准输入中读取数据
(4) 这个测试要求校验在源文件中和目的文件中各计算一次，然后比对两次校验结果
(5) cksum(check and sum循环冗余) 和 md5sum(计算md5)用法类似
【备注二】chsum, md5sum, sha1sum命令的主要用途:
	用途一: 确保文件从一个系统传输到另一个系统地过程中没有被损坏
	用途二: 检查文件或目录是否被改动过
【总结一】cksum, md5sum, sha1sum:
	cksum：计算文件的CRC校验码(循环冗余校验码)和字节数，使用较少
	md5sum：计算和检查md5值；主要用于生成指纹，使用的比cksum多
	sha1sum: 和md5sum都可用于哈希校验,加密效果更好一点,md5sum使用得更为广泛
【dos2unix命令】
 
【实例 | 技巧】
dos2unix file                          # 转单个文本文件， 注意:可执行文件不用转换
dos2unix file1 file2 file3                # 一次行转换多个文件
dos2unix -k file                        #  保留源文件的时间戳
dos2unix -n old_file  new_file         # 保留源文件，输出新文件
cat test.txt | tr -d '\r' | cat -v           # 通过tr来删除, -v参数能显示^M字符
cat  test.txt | sed  's:\r::' | cat -v      # 通过sed来删除
dos2unix *.sh                        #  同类型的.sh脚本批量转
find . -type f -exec dos2unix {} \;      # 多种文本文件，如何进行全部转换
【归纳 | 总结】
【备注一】为什么要用dos2unix
Windows和Linux中文件的换行符的不同，导致文件间的一些兼容问题，Windows系统中用/r/n来表示换行，Linux中用/n来表示换行，Windows的文本文件，直接到Linux中使用可能会出错，因为多出了“/r”字符，具体表现就是每行后面有个字符^M，通过dos2unix 来将window的文本文件转换来适应Linux
【总结一】dos2unix与unixtodos
(1)	dos2unix: 将Windows下的文件转成适应Linux系统的文件
(2)	unix2dos: 将Linux下的文件转成适应Windows系统的文件
(3)	用法一致:  unix2dos filename
(4)	备注: 目前阵列上没有unix2dos命令
【file命令】
 
【实例 | 技巧】
file install.log               # 显示该文件的文件类型
file -L /var/mail             # 显示连接文件指向文件的类型
file /etc/*                   # 显示/etc目录下所有文件的文件类型
file -s /dev/sd-[0-9][0-9]a    # 检查块文件，获取文件系统信息
【归纳 | 总结】
【备注一】Linux中的文件类型: 
(1) 普通文件: 纯文本文件(ascii)，二进制文件(binary)，数据格式文件(data)
(2) 目录文件(第一个字符为d的，类似于: drwxr-xr-x)
(3) 字符设备和块设备(第一个字符为b, 比如ls -l /dev/sda, 第一个字符为c，字符设备)
(4) 套接字文件(第一个字符为s，比如:mysql.sock)
(5) 符号连接文件(第一个字符为l, 比如ls -l /var/mail)
(6) 管道文件(FIFO, first in first out)
【总结一】file命令作用:
file命令的作用是用于检验文件的类型，并打印至终端。主要按以下顺序来完成：
(1) 检验文件系统中支持的文件类型。
(2) 检验magic file规则(如C文件，它会有#include字样；tar文件的前几个字节会有特殊的规则)
(3) 检验文件内容的语言和字符集
【umask命令】
 
【实例 | 技巧】
umask              # 获取当前的权限掩码, 0022，第一位是GID/UID，022(ugo)
umask -S           # 以文字的方式来显示，比如说: u=rwx, g=rx, o=rx
umask 002        # 拿others的权限属性去掉写(w)的权限
【归纳 | 总结】
【备注一】关于umask命令的几点说明:
(1) 默认用户建立的文件的权限: 666(-rw-rw-rw)， 即没有执行的权限
(2) 默认用户建立的目录的权限: 777(drwxrwxrwx)
(3) 两个权限减去umask设置的权限掩码，就能得出文件和目录的实际权限
(4) 基于安全方面的考虑，root的默认umask是022, 该设置可参考/etc/bashrc内容
(5) 想更改整个系统全部默认的umask值，可以更改/etc/profile，一般不建议改
【扩展 | 引申】
【引申一】按照字符的方式来计算umask值:
假如umask设置为003（即去掉others的写+执行权限）
比如说: 默认文件权限666-003=663即others还具备wx权限，这是错误的。
正确的计算:
文件: (-rw-rw-rw-) - (-------wx)  = -rw-rw-r--
目录: (drwxrwxrwx) - (-------wx) = drwxrwxr--
【touch命令】
 
【实例 | 技巧】
touch file             # 修改file文件的时间为系统时间，若file不存在，则创建新文件
touch /etc/nologin    # 系统维护期间禁止用户登录，但不限于SSH登录
touch -c -t 201511301130.45 file  # 设定文件的时间戳, 不存在则不创建新文件
touch -r /etc/passwd file          # 将后者的时间戳设置为前面的一样
touch -a text                     # 修改文件的访问时间
touch -d "11/30/2015" *.sh        # 统一修改shell脚本的时间戳为2015/11/30
touch -d "10:18am 11/30/2015" text    # 2015年11月30日 上午10点18分
touch file1 file2 file3                   #  同时创建多个文件
touch -d "2 days ago" /etc/passwd     # 同样可以修改时间
find /var -name * -exec touch {} \;      # 若发现系统文件时间都不对了，统一修改
【归纳 | 总结】
【备注一】-t选项的时间格式[[CC]YY]MMDDhhmm[.ss]说明:
CC   表示世纪
YY   表示年
MM  表示月
DD   表示日
hh   表示小时
mm  表示分钟
ss    表示秒    
比如: 201510281200.35  世纪20可有可无
【总结一】touch命令的两个主要用途:
主要用来创建新文件和修改创建时间
(1) touch命令最主要用在创建新的空文件， 且用户必须拥有该目录下的写权限
(2) 可以用默认当前时间来更新文件的访问时间和修改时间，也可以指定参数来更新
【mkdir命令】
 
【实例 | 技巧】
mkdir emptydir                # 创建空目录文件
mkdir dir1 dir2 dir3 dir4       # 同时创建多个目录
mkdir -m 770 download       # 权限设置为u,g可读、写、执行，others无权访问
mkdir -p dir1/dir2/dir3        # 递归创建多个目录，若dir1不存在，必须加-p参数
mkdir -p /root/dir1/dir2/dir3   # 上例以相对路径，本例以绝对路径来创建目录
mkdir -m=r-- dir1             # 创建并设置主，组，其他用户只只有读权限的目录
【归纳 | 总结】
【备注一】rmdir
rmdir是remove directory的缩写; mkdir的反操作 rmdir -p dir1/dir2/dir3
【备注二】一次性创建指定权限的工程目录实例
 
【rm命令】
 
【实例 | 技巧】
rm -i file      # 在删除file文件时，先确认
rm -f *.c      # 强制删除所有后缀为.c的文件
rm -rf /test    # 强制递归删除/test目录下的所有子目录及文件
【归纳 | 总结】
【备注一】关于rm的几点说明:
(1) 为安全起见，很多Linux版本默认有-i参数
(2) 如果确定目录不要了，可以使用rm -rf来循环删除
(3) 有时使用了参数 -f，但仍然会询问是否覆盖某文件，这是因为某些服务器，会默认增加别名 alias rm='rm -i',当执行cp操作时，实际执行的是 rm -i，该问题可以这样解决： vi ~/.bashrc,在alias rm='rm -i'前使用#注释掉即可
【备注二】运用mv命令批量修改文件后缀示例:
比如我们要批量修改后缀为.py的文件为，这个时候就需要用到mv命令
 
实现脚本如下: 
 
【mv命令】
 
【实例 | 技巧】
mv 2014.log 2015.log                  # 文件重命名，也是最常用的, 最好加i参数
mv -t /tmp 2013.log 2014.log 2015.log  # 将三个文件移动到/tmp，注意目标文件放前面
mv -v 2013.log 2014.log 2015.log /tmp  # 效果同上, 显示详细执行过程
mv dir1 dir2             # 若dir2不存在，则将dir1命名；若已存在，则dir1下文件移动到dir2中
mv -b file1 file2          # 若file2存在，在改名前会先备份，备份的文件名为file2~
mv -i 2014.log 2015.log    # 将文件file1改名为file2，如果file2已经存在，则询问是否覆盖
mv -u file1 file2            # file1比file2新则更新，否则更新失败
【归纳 | 总结】
【备注一】关于mv命令的几点说明:
(1) Linux中覆盖和重命名的概念几乎是一样的，没有Windows中所谓的rename这一说法
(2) 选项可以写在任意位置，可以mv f1 -v f2，也可以mv -v f1 f2，还可以mv f1 f2 -v
【cp命令】
 
【实例 | 技巧】
cp ~/.bash_history /tmp/history    # 拷贝文件到/tmp目录下，并重命名
cp /etc/file1 /etc/file2 /etc/file3  .  #  多文件拷贝文件到当前目录
cp  -r /etc /tmp                   # 递归复制
cp -a /var/log/wtmp wtmp_1       # 拷贝wtmp文件到本地，并保留所有属性
cp -s wtmp wtmp_slink             # 对wtmp文件建一个快捷方式
cp -l wtmp wtmp_hlink             #  建硬连接文件
cp -i /etc/passwd passwd          # 源文件存在，拷贝之前会先询问
cp -u ~/.bashrc  /tmp/bashrc     # 目标文件比源文件旧才更新，常用于shell脚本
【归纳 | 总结】
【备注一】拷贝时先要搞清楚下面几个问题:
(1) 是否需要完整保留源文件的信息
(2) 源文件是否为连接文件
(3) 源文件是否为目录，如为目录，要用-r或-R参数
PS: 拷贝时为防覆盖最好用-i参数提醒，或加个别名alias cp='cp -i'
【scp命令】
 
【实例 | 技巧】
【从本地复制到远端 】scp 本地文件  远端用户@远端IP:远端文件夹
scp /home/permitdir/A.tgz  admin@129.7.230.74:/home/permitdir/
【从远端复制到本地】 scp 远端用户@远端IP:远端文件夹  本地文件
scp -r admin@129.7.230.74:/home/permitdir/  /tmp/    # 递归拷贝目录
【归纳 | 总结】
【备注一】关于scp命令的几点说明:
(1)	如远程服务器有为scp命令设置了指定的端口，需用-P参数设置命令的端口号 
scp -P 1234 remote@server:/usr/local/sin.sh /home/administrator
(2) 用户必须具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的
(3) 一般能ssh就能执行scp的操作，它们用到时同一个端口，防火墙默认是打开的
# iptables -I　INPUT -p tcp --dport 22 -j ACCEPT
【备注二】cp和scp区别:
(1) cp和scp前者是服务内部的拷贝，后者是服务器之间的拷贝, 比FTP安全
(2) cp是copy的简写，是Linux服务器内部不同目录之间的复制
(3) scp是Linux服务器基于SSH登录并进行安全的远程文件拷贝命令
【paste命令】
 
【实例 | 技巧】
paste names scores                            # 合并多文件以列的方式
paste -d":" names scores                       # 以冒号作为列与列的分隔符
paste -s names scores                          # 将多行数据合并到一行
cat /etc/group | paste /etc/passwd - | head -n 3  # 多文件合并
【归纳 | 总结】
【备注一】关于paste命令的几点说明:
(1)  paste的拼凑原理和cut一样，行为正好相反，一个是切割，一个是合并
(2)  paste命令在shell脚本中常于与cut,join,sed等组合使用
示例如下:
 
【cut命令】
 
【实例 | 技巧】
LANG="zh_CN.UTF-8"; date | cut -b 1-7,10-15   # 2015年09月
date '+%D ' | cut -c 7-8  # 从输出21/12/15中截取年份15年， 注意区别-b参数，中文算一个字符
head -n5 /etc/passwd | cut -d : -f 1,3-5  # 取第一列，第三，四，五列
【归纳 | 总结】
【备注一】cut命令主要接受三个定位方式:
	第一: 字节(bytes) 选项-b
	第二: 字符(chars) 选项-c
	第三: 字段(fields) 选项-f
PS: 如果域分割中含多个空格的话，用cut处理起来就比较麻烦
【join命令】
 

【实例 | 技巧】
join file1 file2           # 两个文件交集，file1中的内容放置左侧，file2中的列右侧
join -a1 -a2 file1 file2    #  两文件的并集
join -v2 file1 file2        # 两文件的差集
join -v1 v2 file1 file2     # 两个文件的对称差集
join -j 1 file1 file2        # 指定第一列作为匹配字段，和上面等价
join -o 1.1 2.2 file1 file2   # 显示第一个文件的第1列，第二个文件的第2列
join -a1 file1 file2         # 在显示相关联的部分的同时，显示file1中不匹配的项
join file1 file2 | join file3 - | join file4 -   # 将四个文件合并起来
join -v 1 file1 file2                     # 将file1中不匹配的行列出
join -t ':' /etc/passwd /etc/shadow     # 将两个文件以:分割，合并起来
【归纳 | 总结】
【备注一】关于join命令的几点说明:
(1) 与paste命令相似，一个以特殊方式来合并两个文件的强有力工具，用法很像SQL
(2) join一般用在特定的处理或用在Shell脚本中与cut,paste,sed,grep联合对文本进行处理
【fold命令】
 
【实例 | 技巧】
fold -w 100 messages    # 将文件折叠成每行100字符显示，在文本处理或Shell有时有用.
【colrm命令】
 
【实例 | 技巧】
colrm 4                          # 从第4列开始删除以后所有输入字符串
colrm 4 6                        # 从标准输入中过滤掉第四列到第六列
colrm 4 6 < filename             # 从输入文件中删除第四列到第六列
colrm 4 6 < file1 > file2          # 过滤掉file1中第4~6列，输出到file2
【归纳 | 总结】
【备注一】关于colrm命令的几点说明:
(1) colrm是column remove的简写，常用在shell中对文件进行处理
(2) 如果文件包含tab和不可打印字符，可能会引起不可预期的行为
示例如下:
 
【comm命令】
 
【实例 | 技巧】
comm file1 file2                  # 默认以列的方式显示两个文件，和公共部分，以Tab分隔
comm -12 file1 file2              # 求交集
comm -3 file1 file2               # 删除公共部分，保留不同部分
comm -23 file1 file2              # 差集，只包含文件1中独有的部分
comm -13 file1 file2              # 差集，只包含文件2中独有的部分
comm -3 file1 file2 | sed 's/^\t//'  # 将制表符（\t）删除，以便合并成一列
【归纳 | 总结】
【总结一】comm与diff命令区别:
(1) 都可以用来比较两个文件内容
(2) comm用于对有序文件进行比较
(3) diff用于逐行比较列出其差异的详细信息，常用于补丁文件
【备注一】comm命令在实际运用的示例:
比如两个人名的文件，文件中都含Jerry； 接下来要删除公共部分，保留不用部分
 
 
【patch命令】
 
【实例 | 技巧】
patch -p0 < /home/test/patch-3.1           # 安装补丁，在当前目录下打补丁
patch -R -p1 < /home/test/patch-3.1        # 卸载补丁
【归纳 | 总结】
【总结一】打补丁的步骤：
(1) 用diff工具比较新旧代码，生成patch文件；
(2) 使用patch命令，将patch文件合并到原有代码；
(3) 检查有无无法patch的文件，修改或重新选择是否对其做patch。
(4) patch打完了就可以直接编译了。
PS: p(n)一般取0,1,2 表示忽略前面的几层目录和/最左边部分,最好保证目录对齐
【备注一】patch命令的简单示例：
	准备数据，并用diff来生成补丁文件:
 
	对name1打补丁，从而得到name2:
 
	对name2打补丁，让其还原成name1: 
【split命令】
 
【实例 | 技巧】
split -l 200 /var/log/messages        # 每200行拆分为一个小文件
split -b 100k data                    # 把data文件按照每100k来拆分小文件
split -b 100k data data_split_          # data_split_为输出文件的前缀
split -b 100k data -d -a 3 data_split_   # -d参数 -a length指定后缀长度
【归纳 | 总结】
【备注一】关于split的几点说明:
	适用场景: 大文件传输；大日志文件打开很耗系统资源，就要考虑用split来切割
	常用命令: 用于切割常用split和csplit两个命令
	制造数据: dd if=/dev/zero bs=1000M count=1 of=data
【备注二】大文件拆分的实际例子: 
	准备数据  dd if=/dev/zero of=data bs=100M count=1 
	拆分数据  split -b 10m data -d -a 3 data_split_
	合并数据  cat data_split_* > data
	验证数据  md5sum data
                                         
【csplit命令】
 
【实例 | 技巧】
csplit file 100                    # 将file文件从100行为分界点，切割为2份;xx00, xx01
csplit -n 3 file 100                # 将file从100行切割为两份，文件位数xx000,xx001
csplit -n 3 -f file- file 100         # 输出为file-000, file-001
csplit file 11 22 44               # file将切割成1-10行，11-21行, 22-43行,44行后，四个文件
csplit -n 3 file 100 {*}            # 按每100行来分割，{*}按模式匹配，直至文件结尾
csplit -f chap book /Chapter X/  # 按Chapter X来切割成两部分,chap00,chap01
csplit -f chap book /Chapter X/+4   # 找到该关键字后4行才是分割点
csplit -k -f prefix- file 1000 {10}      # 即使中断也保留文件
【归纳 | 总结】
【备注一】split与csplit:
(1) 两者都是Linux下的拆分工具;split适用于常规拆分
(2) csplit适用于特殊场合的拆分:不定长拆分，关键字匹配
【备注二】csplit命令实例:
server.log为准备的数据，使用csplit命令来切割:
 
【cmp命令】
 
【实例 | 技巧】
cmp A.bin A.bin.bak       # 比较bak文件是否是原来文件的备份
cmp -l A.bin A.bin.bak     # 标出所有不一样的地方， 以八进制显示
cmp -s A.bin A.bin.bak     # 不显示任何信息。相同输出0，不同输出1， 错误输出2
【归纳 | 总结】
【备注一】关于cmp命令的几点说明:
(1) 如两文件完全一致，无信息显示，若有差异标出第一个不同的字符和列数编号
(2) cmp主要比较两个二进制文件，而diff主要比较两个文本文件
(3) 执行cmp file1 file2命令，若出现下面这两种情况:
	情形一:file1 file2 differ: char 23, line 6   
>>>说明file1文件与file2文件内容在第6行的第23个字符开始有差异 
	情形二:cmp: EOF on file1   若输出是这样的结果
>>>说明file2前半部分与file1相同。但在file2中还有其他数据。
【备注二】cmp命令在shell脚本中的常用示例:
 
【diff命令】
 
【实例 | 技巧】
diff 2014.log 2015.log            # 比较两个文件，输出结果中c:改变 d:删除 a:添加
diff -y -W 40 2014.log 2015.log   # 以并列的方式显示来差异文件，列宽为40
diff -c 2014.log 2015.log         # 全文显示 !代表差异  +后文多出一行  -后文少了一行
【归纳 | 总结】
【备注一】关于diff脚本的几点说明:
(1) diff&patch 常用在项目有BUG，但无权修改，就用diff生成补丁文件，供程序员打补丁
(2) diff有很多功能平时我们不常用到，最常用的功能莫过于生成patch文件了
(3) diff生成补丁文件最常用的参数-Naru
 
