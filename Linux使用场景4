
7	系统设置
【passwd命令】
 
【实例 | 技巧】
passwd                        # 不带用户名的话，则为更改root本身的密码
passwd guest                  # 更改guest账号的密码
passwd -x 100 -n 30  admin    # 设置密码的最小与最大有效天数
passwd -x 100 -n 30  admin    # 设置密码的最小与最大有效天数
passwd admin -w 7             # admin密码生效前7天告警
passwd -i 10 test               # 设置test账号密码过期10天后，账户失效
passwd -d test                  # 则为删除test账号的密码
passwd -l test                   # 锁住test账号
passwd -S admin                # 显示账户状态信息，注: 阵列passwd无该参数
passwd -aS                     # 显示所有用户的密码信息，一般与-S一起使用
【归纳 | 总结】
【备注一】-S状态说明: 
root NP 06/19/2013 0 99999 7 -1
显示账户状态信息，共有7个字段，分别是登录名、L（P or NP）、上次修改时间、最小年龄、最大年龄、警告期、inactive period。这些ages的单位都是天
【备注二】与用户、组账户信息相关的文件:
	存放用户信息： /etc/passwd /etc/shadow
	存放组信息  ： /etc/group  /etc/gshadow
	用户信息分析; 例如: admin:x:0:0:root:/home/permitdir/:/bin/bash 
	用户名|密码|用户id|所在组|组描述|用户家目录|用户缺省Shell
【clear命令】
 
【实例 | 技巧】
clear                       # 清空终端屏幕
【归纳 | 总结】
【备注一】关于clear命令的几点说明:
	Linu下的clear与DOS下cls命令区别，前者只是向后翻屏，后者是真正清屏
	Ctrl+L同样可以清屏，用vi编辑文件时，如果界面布局混乱，用该命令非常有效
	用printf "\033c" 或者 printf "\ec", 可以达到真正清屏的目的
	reset也可以真正清空屏幕,在终端错乱,输入字符不在光标位置，用该命令非常有用
	clear保留历史，reset不保留历史
【yum命令】
 
【实例 | 技巧】
【安装包】 
yum install                  # 全部安装 
yum install package1        # 安装指定的安装包package1 
yum groupinsall group1      # 安装程序组group1
【更新包】
yum update                  # 全部更新 
yum update package1         # 更新指定程序包package1 
yum check-update            # 检查可更新的程序 
yum upgrade package1        # 升级指定程序包package1 
yum groupupdate group1      # 升级程序组group1
【查找包】
yum info package1           # 显示安装包信息package1 
yum list                      # 显示所有已经安装和可以安装的程序包 
yum list package1            # 显示指定程序包安装情况package1 
yum groupinfo group1        # 显示程序组group1信息
yum search string             # 根据关键字string查找安装包
【删除包】
yum remove | erase package1    # 删除程序包package1 
yum groupremove group1       # 删除程序组group1 
yum deplist package1            # 查看程序package1依赖情况
【清缓存】 
yum clean packages             # 清除缓存目录下的软件包 
yum clean headers              # 清除缓存目录下的 
headers yum clean oldheaders   # 清除缓存目录下旧的 headers
【归纳 | 总结】
【备注一】关于yum命令的几点说明:
(1)	yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，命令简洁好记
(2)	yum基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装
【ulimit命令】
 
【实例 | 技巧】
ulimit -Hs 64         # 限制硬资源，线程栈大小为64K
ulimit -Sn 32         # 限制软资源，32个文件描述符
ulimit -a             # 显示当前所有的limit信息
ulimit -c unlimited   # 对生成的core文件的大小不进行限制
ulimit -d unlimited   # 对进程的数据段大小不进行限制
ulimit -f 2048        # 限制进程可以创建的最大文件大小为2048 blocks
ulimit -l 32           # 限制最大可加锁内存大小为32 Kbytes
ulimit -m unlimited   # 对最大内存不进行限制
ulimit -n 128         # 限制最大可以使用128个文件描述符
ulimit -p 512         # 限制管道缓冲区的大小为512 Kbytes
ulimit -s 512         # 限制线程栈的大小为512 Kbytes
ulimit -t unlimited    # 对最大的CPU占用时间不进行限制
ulimit -u 64          # 限制用户最多可以使用64个进程
ulimit -v 200000      # 限制最大可用的虚拟内存为200000 Kbytes
【归纳 | 总结】
【备注一】为什么要用ulimit来限制资源
假如一台Linux主机上同时登陆了10个人，在系统资源无限制的情况下，这10个用户同时打开了500 个文档，而假设每个文档的大小有 10M，这时系统的内存资源就会受到巨大的挑战。

而实际应用的环境要比这种假设复杂的多，例如在一个嵌入式开发环境中，各方面的资源都是非常紧缺的，对于开启文件描述符的数量，分配堆栈的大小，CPU 时间，虚拟内存大小，等等，都有非常严格的要求。资源的合理限制和分配，不仅仅是保证系统可用性的必要条件，也与系统上软件运行的性能有着密不可分的联 系。这时ulimit可以起到很大的作用，它是一种简单并且有效的实现资源限制的方式
【备注二】ulimit命令可作以下方面的限制和优化:
ulimit用于限制shell启动进程所占用的资源，支持以下各种类型的限制：
	所创建的内核文件的大小
	进程数据块的大小
	Shell进程创建文件的大小
	内存锁的大小
	常驻内存集的大小
	打开文件描述符的数量
	分配堆栈的最大大小
	CPU 时间
	单个用户的最大线程数
	Shell进程所能使用的最大虚拟内存
	硬资源和软资源的限制
Ps:  ulimit只对登录的shell会话生效，要长久生效必须修改配置文件
【chkconfig命令】
 
【实例 | 技巧】
chkconfig telnet on           # 开启Telnet服务
chkconfig telnet off           # 关闭telnet服务
chkconfig --add httpd           # 增加httpd服务
chkconfig --del httpd            # 删除httpd服务
chkconfig --level httpd 235 on   # 设置httpd在运行级别为2、3、5的情况下都是开启的状态
chkconfig --list                  # 列出系统所有的服务启动情况
chkconfig --list mysqld          # 列出mysqld服务设置情况
chkconfig mysqld on            # 设定mysqld在各等级(2、3、4、5)都为开启状态
【归纳 | 总结】
【备注一】几个常用运行等级意义:
	等级0表示： 表示关机
	等级1表示： 单用户模式
	等级2表示： 无网络连接的多用户命令行模式
	等级3表示： 有网络连接的多用户命令行模式
	等级4表示： 不可用
	等级5表示： 带图形界面的多用户模式
	等级6表示： 重新启动
Ps. 运行等级0和6代表关机和重启，一般服务不运行在该级别
【备注二】如何增加一个服务：
(1) 将服务脚本存放在/etc/ini.d/目录下
(2) chkconfig --add servicename
(3) chkconfig --level 235 servicename on
【备注三】关于init文件说明:
每个被chkconfig管理的服务需要在对应的init.d下的脚本加上两行或者更多行的注释。
第一行告诉chkconfig缺省启动的运行级以及启动和停止的优先级。如果某服务缺省不在任何运行级启动，那么使用 - 代替运行级。
第二行对服务进行描述，可以用\ 跨行注释。
例如，random.init包含三行：
# chkconfig: 2345 20 80
# description: Saves and restores system entropy pool for \
# higher quality random number generation.
【set命令】
 
【实例 | 技巧】
set                                # 显示环境变量
set -o                              # 查看当前设置情况
set -o vi                           # 打开vi选项
set +o vi                           # 关闭vi选项
set PATH="/bin:/usr/bin:/usr/sbin"  # 直接设置变量
【归纳 | 总结】
【备注一】vi中的常用set项:
	:set ai                  # 让vi自动对齐
	:set noai               # 取消自动对齐
	:set showmatch        # 高亮显示
	:set noshowmatch      # 不高亮显示
	:syntax on             # 开启语法高亮显示
【time命令】
 
【实例 | 技巧】
time date                                   # 最常用的用法，直接+命令和参数
time find / -name "job.sh"                   # 评估find命令的执行时间
{ time find . -name "mysql.sh"; } 2>result.txt  # shell关键字重定向方式
【归纳 | 总结】
【备注一】real, user, sys三者解读:
(1) real: 代表的是程序从开始到结束的全部时间，即使程序不占CPU也统计时间。而user+sys是程序占用CPU的总时间，因此real>user+sys.
(2) user:代码借助操作系统底层API来访问硬件或者内存所消耗CPU时间
(3) sys:有权限访问操作系统最底层的内存，CPU所消耗的CPU时间
【备注二】time与/usr/bin/time区别:
(1) 两者都可以测试程序运行时间
(2) 前者是Shell的关键字，精度可达10毫秒
(3) 后者精度略低，但能提供丰富的参数选项，包括制定输出文件等功能
(4) 后者输出文件示例: $ /usr/bin/time -o outfile ls
(5) 后者输出格式示例: $ /usr/bin/time -f "time: %U" ls
【总结一】以time为例说明shell关键字如何重定向输出:
time的输出信息是打印在标准错误输出上的; time的输出信息重定向到文件里面，因为time是shell的关键字，shell做了特殊处理，它会把time命令后面的命令行作为一个整体来进行处理，在重定向时，实际上是针对后面的命令来的，time命令本身的输出并不会被重定向的。处理办法:
方法一:  $ (time find . -name "*.sh") 2>result.txt     # 通过子shell的方式来重定向
方法二:  $ { time find . -name "*.sh"; } 2>result.txt   # 通过{}的方式来重定向
【alias命令】
 
【实例 | 技巧】
alias                          # 列出当前所有的别名设置
alias rm='rm -i'                # 增加别名有提示的删除，更安全些
alias ll='ls -lart --color=auto'   # 设置别名
unalias ll                      # 用unalias来删除别名
【归纳 | 总结】
【备注一】关于alias命令的几点说明:
(1) 必须用单引号来将原来的命令引起来，防止特殊字符导致错误
(2) 需要注意别名和其他命令冲突的情况或安全方面的情况
示例如下:
 
【扩展 | 引申】
【引申一】alias在全局或是有环境中的配置:
(1) alias操作仅在当前的shell有效，要想永久生效，必须在profile或bashrc设置
(2) /etc/profile，/etc/bashrc 是系统全局环境变量设定
 ~/.profile，~/.bashrc用户家目录下的私有环境变量设定
(3)	修改完后，用source /etc/profile使修改后配置生效，建议在私有环境变量中设定
【引申二】设置函数的方式起到别名的作用:
 
【declare命令】
 
【实例 | 技巧】
declare -i X; X=6/3; echo $X                        # 定义变量可为表达式
declare -f                                         # 不加函数名的话，会显示所有函数体
declare -i VAR=1                                  # 声明整形变量并赋值
declare -x VAR1=10                               # 相当于export，其他shell也可使用该变量
declare -r VAR                                    # 设置为只读
declare +i VAR                                    # 取消设置变量VAR属性
【声明数组变量方式一】
declare -a A=(1 2 3 )
echo ${A[*]}
echo ${A[0]}
【声明数组变量方式二】
declare -a citys='([0]="CD" [1]="BJ" [2]="SH")'    
echo ${citys[1]}                                # 显示变量内容，输出:BJ
echo ${citys[@]}                               # 显示整个数组变量内容,输出:CD BJ SH
【声明数组变量方式三】
declare -a names
names[0]=Jerry; names[1]=Alice; names[2]=David
echo ${#names[*]}
echo ${names[@]}
echo ${#names[@]}
【归纳 | 总结】
【总结一】Shell中常用的内置命令:
alias, bg, bind, break, builtin, cd, command, comp, gen, complete, continue, declare, dirs, disown, echo, enable, eval, exec, exit, export, fc, fg, getopts, hash, help, history, jobs, kill, let, local, logout, popd, printf, pushd, pwd, read, readonly, return, set, shift, shopt, source, suspend, test, times, trap, type, typeset, ulimit, umask, unalias, unset, wait
【总结二】Linux的本地变量和环境变量:
(1) 本地变量和环境变量(全局变量)
(2) 本地变量我们可以用export或declare来赋值，用法如下:
export 变量名=值  例如: export total=50
declare -x 变量名=值 例如: declare -x total=50
(3) 用set命令查看系统当前的所有的变量
(4) 用env命令可以查看当前系统的所有环境变量
(5) 用export命令查看当前系统的所有本地变量
【export命令】
 
【实例 | 技巧】
export -p                                  # 列出当前Shell的变量值
export WEEK=7                            # 定义环境变量并赋值
export $PATH=$PATH:/usr/bin              # 用来设置路径变量，对所有子shell生效
export -n WEEK; echo $WEEK               # 实际上未删除，只是不显示而已
【归纳 | 总结】
【备注一】关于export的几点说明:
(1) export设置存放于内存，只能应用在bash环境下，csh应用不了
(2) export可增删，修改环境变量，供后续执行的程序使用，仅作用于该次登陆操作
(3) 要想长久生效，必须修改/etc/profile文件，然后执行source /etc/profile命令
【总结一】几个常用的配置文件说明:
	/etc/environment是设置整个系统的环境，与登陆用户无关
	/etc/profile是设置所有用户的环境，与登录用户有关
	/etc/bashrc:为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.
	~/.bash_profile:每个用户都可使用该文件输入专用于自己使用的shell信息
	~/.bashrc:该文件为用户bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.
	~/.bash_logout:当每次退出系统时,执行该文件
【dmesg命令】
 
【实例 | 技巧】
dmesg -c                    # 信息就清空了
dmesg | less                 # 以分页的方式来显示开机信息
dmesg | tail -20              # 查看开机的尾部后20条信息
dmesg | grep -i sda          # 显示被系统检测到的硬盘设备,TTY,USB,memory,dma等
watch "dmesg | tail -20"      # 实时监控dmesg的日志输出
【归纳 | 总结】
【备注一】dmesg命令的几点说明:
	该命令用来探测系统内核模块加载情况, 比如: $ dmesg | grep acpi
	该命令用来查看硬件的检测信息或者断开、连接的信息
	该命令用来获得诸如系统架构、cpu、挂载的硬件，RAM等大量的系统信息
【enable命令】
 【实例 | 技巧】
enable                          # 显示shell内建命令
enable -n  type                 # 关闭内部命令type
enable -a type                  #  开启内部命令type
【归纳 | 总结】
【备注一】内部命令和外部命令：
	内部命令在系统启动时就调入内存，是常驻内存的，所以执行效率高
	外部命令是系统的软件功能，用户需要时才从硬盘中读入内存
【备注二】关于enable命令的几点说明:
	用enable -all来显示所有激活或关闭的指令
	用enable -n COMMAND来关闭shell内建指令
	用enable -a COMMAND来激活shell内建指令
【at命令】
 
【实例 | 技巧】
at -l                                         # 等同于atq，显示当前作业号
at -c 8                                       # 8为具体的job号   
at 8pm tomorrow -v -f /script/job.sh          # 明天下午8点执行脚本
atrm job 3                                   # 删除job为3的进程
at 23:59 12/31/1999 echo 'the end of world !'  # 某个时间点执行某个命令
【归纳 | 总结】
【备注一】如果atd服务没起来，处理步骤: 
(1) ps -ef | grep atd | grep -v "grep"  查看是否该进程启动
(2) /etc/init.d/atd start  若无，则用该命令启动atd服务	
(3) chkconfig --level 2345 atd on 也可进一步设置开机即启动
【备注二】at命令常用的两种情形:
	凌晨三点执行某个命令   at 03:00 <Enter>      <EOT>是输入Ctrl+D来结束任务设置
 
	凌晨三点执行某个脚本
 
【总结一】 常用时间格式
HH:MM                                         at 21:00
HH:MM YYYY-MM-DD                           at 21:00 2015-11-30
HH:MM[am|pm] [Month] [Date]                   at 09pm May 1
HH:MM[am|pm]+数字[minutes|hours|days|weeks]  at 21:15 + 5 minutes
绝对时间：HH:MM     DD.MM.YY , MM/DD/YY, YYYY-MM-DD
相对时间：now+#单位，例如: $ now + 5 days
模糊时间：noon(12:00PM)，midnight(12:00AM)，teatime(4:00PM)
【总结二】配置文件/etc/at.deny和/etc/at.allow
	如果deny单独存在，则是deny以外的所有用户都可以使用at命令
	如果allow单独存在，则是只允许allow内的用户可以使用at命令
	如果同时存在，则只允许allow内的用户使用at命令
	如果同时不存在，则只允许root账号执行at操作
【hwclock命令】
 
【实例 | 技巧】
hwclock            # 显示当前时间，即硬件时钟。等价于hwclock -r
hwclock -w        # 将系统时钟同步到硬件时钟
hwclock -s         # 将硬件时钟同步到系统时钟
【归纳 | 总结】
【总结一】硬件时钟和系统时钟:
(1) Linux中有硬件时钟与系统时钟两种时钟,它们之间存在差异
(2) 硬件时钟是指主机板上的时钟设备，可在BIOS画面设定的时钟。
(3) 系统时钟是指kernel中的时钟; 当Linux启动时，系统时钟会去读取硬件时钟的设定，之后系统时钟即独立运作.所有Linux命令与函数都是读取系统时钟的设定。
(4) hwclock既可以将硬件时钟同步到系统时钟，也可以将系统时钟同步到硬件时钟
【eval命令】
 
【实例 | 技巧】
eval pwd; ls -lart                     # 连接多个命令, 用分号间隔
var="id | cut -d'  ' -f1"; eval $var     # 对|等特殊字符进行处理
【归纳 | 总结】
【备注一】命令优先级表:
	别名
	关键字
	函数
	内置命令
	脚本或可执行程序($PATH)
【备注二】eval命令的几点说明:
(1) 执行大括号扩展，例如a{b,c}变成ab ac
(2) 如果~位于单词开头，用$HOME替换~。使用usr的主目录替换~user
(3) 对任何以符号$开头的表达式执行参数(变量)替换
(4) 对形式$(string)的表达式进行命令替换;这里是嵌套的命令行处理
(5) 计算形式为$((string))的算术表达式
【总结一】eval命令的执行步骤和应用场景:
执行步骤1: 第一次，执行变量替换
执行步骤2: 第二次，执行替换后的命令串 
应用场景1: 命令行结束符（；｜ &）
应用场景2: 重定向符（< >> >）
应用场景3: '', "", ()
【echo命令】
 
【实例 | 技巧】
echo "Hello World"                           # 显示普通字符串，等价于$ echo Hello World
echo "\"Hello World\""                         # 显示转义字符
echo "Today's date time is : `date`"              # 显示命令执行结果
echo -e "Hello\nWorld"                         # -e开启转义, \n换行，如果是\c则是不换行
echo -n "please input your name: "; read name; echo "Your name is:$name"
echo "PATH is $PATH"                           # 显示变量
echo "127.0.0.1 www.test.com test" >> /etc/hosts # 尾部添加内容
echo hello >&2                                 # shell脚本中常用，调试时防信息干扰
echo *.sh                                     # 打印指定的文件类型，这个就类似于ls的功能了
echo -e "\033[31mLinux\033[0m"              # 用-e参数，红色打印输出Linux
echo -e "\033[1m\033[41mLinux\033[0m"      # 粗体及红色背景打印Linux
【归纳 | 总结】
【备注一】常用特殊字符:
	\a  发出警告声
	\b  会删除字符间的所有空格 $ echo -e "Tom \b&& \bJerry"
	\c  不换行，注意区别\n, 有时Shell脚本中需要，比如提示用户输入信息
	\n  换行
	\r  回车
	\t  插入Tab
	\\  插入反斜杠字符
【备注二】echo命令使用示例:
 
8	压缩解压
【tar命令】
 







9	速查备忘
【if条件语句】
【语法结构】
 
【实例说明】
例1: 条件判断,依照systemtype依次在mml模式或diagnose模式处理
 
例2: 条件判断, 长命令作为一变量，然后对变量进行判断
 
【case选择语句】
【语法结构】
 
【实例说明】
 


【for循环语句】
【语法结构I】类Python模式
 
【实例说明I】
例1:  列表内容直接列出来:
 
例2:  列表内容放置在{}中:
 
例3:  列表内容以seq命令产生，10表示步进, 1:起始  100:终止
 
例4:  列表内容以ls获得，本例即解压缩所有*.gz结尾的文件
 
例5:  列表内容为输入的参数，遍历依次获取参数
 
例6:  列表内容为某个目录下的文件
 
【语法结构II】类C模式
 
【实例说明II】
例1: 用for循环的简单示例
 
例2: 用for循环实现造坏道，踩坏道示例
 
【while循环语句】
【语法结构】
 
【实例说明】
例1: while循环的简单示例
 
例2: while循环常用于遍历文件，然后对文件进行处理，比如
 
例3: while循环，实现一直执行下去，或者死循环简单示例
 

【输入输出重定向】
【文件描述符说明列表】
 

【全部命令行列表】
 

【输入输出流程图】
STDIN      输入文件
STDOUT     输出文件
STDERR     输出错误
 
	如果想屏蔽stdout,stderr, 则重定向到空设备的文件中:
 
【Here Document实例】
 
【几种常用操作符】
 
【常用按键速查表】
 
【Linux启动顺序图】
下面这张图很直观，详细的说明了从机器启动 读取BIOS读取硬盘信息MBR读取启动信息Grubroot挂载信息挂载 /etc/inittab 再到登陆整个启动流程，顺序
 
【Linux中的设备号】
 
【Shell中参数传递】
 
【Linux中目录结构】
 


【vi/vim键盘图】
 
